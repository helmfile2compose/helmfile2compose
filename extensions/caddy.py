"""Caddy reverse proxy provider — built-in IngressProvider implementation."""

import os
import sys

from helmfile2compose.core.ingress import IngressProvider


class CaddyProvider(IngressProvider):
    """Convert Ingress manifests to a Caddy service + Caddyfile."""
    name = "caddy"

    def build_service(self, entries, ctx):
        """Build the Caddy compose service dict."""
        # Extension config with fallback to top-level caddy_* keys for retrocompat
        ext_cfg = ctx.extension_config
        if ext_cfg.get("disabled"):
            return {}

        volume_root = ctx.config.get("volume_root", "./data")
        caddy_volumes = [
            "./Caddyfile:/etc/caddy/Caddyfile:ro",
            f"{volume_root}/caddy:/data",
            f"{volume_root}/caddy-config:/config",
        ]
        # Mount CA secrets referenced by server-ca annotations
        ca_secrets = {e["server_ca_secret"] for e in entries
                      if e.get("server_ca_secret")}
        for secret_name in sorted(ca_secrets):
            caddy_volumes.append(
                f"./secrets/{secret_name}"
                f":/etc/caddy/certs/{secret_name}:ro")
        return {"caddy": {
            "image": "caddy:2-alpine", "restart": "always",
            "ports": ["80:80", "443:443"],
            "volumes": caddy_volumes,
        }}

    def write_config(self, entries, output_dir, config):
        """Write the Caddyfile."""
        if not entries:
            return

        # Extension config with fallback to top-level caddy_* keys for retrocompat
        ext_cfg = config.get("extensions", {}).get(self.name, {})
        caddy_email = ext_cfg.get("email") or config.get("caddy_email")
        tls_internal = bool(ext_cfg.get("tls_internal") or config.get("caddy_tls_internal"))

        filename = "Caddyfile"
        if config.get("disableCaddy"):
            project = config.get("name", "project")
            filename = f"Caddyfile-{project}"

        replacements = config.get("replacements", [])
        by_host: dict[str, list[dict]] = {}
        for e in entries:
            if replacements:
                for r in replacements:
                    e["upstream"] = e["upstream"].replace(r["old"], r["new"])
            by_host.setdefault(e["host"], []).append(e)

        path = os.path.join(output_dir, filename)
        with open(path, "w", encoding="utf-8") as f:
            f.write("# Generated by helmfile2compose — do not edit manually\n\n")
            if caddy_email:
                f.write(f"{{\n\temail {caddy_email}\n}}\n\n")
            for host, host_entries in by_host.items():
                _write_caddy_host_block(f, host, host_entries, tls_internal)
        print(f"Wrote {path}", file=sys.stderr)


def _write_caddy_reverse_proxy(f, entry: dict, indent: str = "\t") -> None:
    """Write a reverse_proxy directive, with TLS transport if upstream is HTTPS."""
    scheme = entry.get("scheme", "http")
    upstream = entry["upstream"]
    if scheme != "https":
        f.write(f"{indent}reverse_proxy {upstream}\n")
        return
    ca_secret = entry.get("server_ca_secret", "")
    f.write(f"{indent}reverse_proxy https://{upstream} {{\n")
    f.write(f"{indent}\ttransport http {{\n")
    if ca_secret:
        sni = entry.get("server_sni", "")
        if sni:
            f.write(f"{indent}\t\ttls_server_name {sni}\n")
        f.write(f"{indent}\t\ttls_trust_pool file"
                f" /etc/caddy/certs/{ca_secret}/ca.crt\n")
    else:
        f.write(f"{indent}\t\ttls_insecure_skip_verify\n")
    f.write(f"{indent}\t}}\n")
    f.write(f"{indent}}}\n")


def _write_caddy_host_block(f, host: str, host_entries: list[dict],
                            tls_internal: bool = False) -> None:
    """Write a single Caddy host block (specific paths first, catch-all last)."""
    specific = [e for e in host_entries if e["path"] and e["path"] != "/"]
    catchall = [e for e in host_entries if not e["path"] or e["path"] == "/"]
    f.write(f"{host} {{\n")
    if tls_internal:
        f.write("\ttls internal\n")
    for entry in specific:
        f.write(f"\thandle {entry['path']}* {{\n")
        if entry.get("strip_prefix"):
            f.write(f"\t\turi strip_prefix {entry['strip_prefix']}\n")
        for directive in entry.get("extra_directives", []):
            f.write(f"\t\t{directive}\n")
        _write_caddy_reverse_proxy(f, entry, indent="\t\t")
        f.write("\t}\n")
    for entry in catchall:
        for directive in entry.get("extra_directives", []):
            f.write(f"\t{directive}\n")
        _write_caddy_reverse_proxy(f, entry)
    f.write("}\n\n")
